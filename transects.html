<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transect Data Entry</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css" rel="stylesheet">
    <style>
        .table-responsive {
            max-height: 400px;
            overflow: auto;
        }
        th.sticky, td.sticky {
            position: sticky;
            left: 0;
            background: #fff;
            z-index: 2;
        }
        th.sticky-2, td.sticky-2 {
            position: sticky;
            left: 80px;
            background: #fff;
            z-index: 2;
        }
        th.sticky-header {
            position: sticky;
            top: 0;
            background: #f8f9fa;
            z-index: 3;
        }
        .toolbar {
            margin-bottom: 1rem;
        }
        .delete-row-btn {
            color: #dc3545;
            cursor: pointer;
        }
        .table thead th {
            vertical-align: middle;
        }
        .table tbody td {
            vertical-align: middle;
        }
        td.sticky {
            padding-left: 5px !important;
        }
        td.sticky .cell-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .insert-row-btn {
            display: inline-block;
            width: 18px;
            height: 18px;
            padding: 0;
            margin-right: 4px;
            border-radius: 50%;
            background: #28a745;
            color: white;
            border: none;
            font-size: 11px;
            line-height: 18px;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
            vertical-align: middle;
        }
        tr:hover .insert-row-btn {
            opacity: 1;
        }
        .insert-row-btn:hover {
            background: #218838;
        }
    </style>
</head>
<body class="bg-light">
<div class="container py-4">
    <div class="toolbar d-flex justify-content-between align-items-center mb-2">
        <div class="d-flex align-items-center">
            <h4 class="mb-0 me-3">Transect Data Entry</h4>
            <div class="d-flex align-items-center me-3">
                <label for="teamName" class="me-2 mb-0">Team:</label>
                <input type="text" id="teamName" class="form-control form-control-sm" style="width: 150px;" placeholder="Team name">
            </div>
            <div class="d-flex align-items-center">
                <label for="chartDatum" class="me-2 mb-0">Chart datum:</label>
                <input type="number" id="chartDatum" class="form-control form-control-sm" style="width: 100px;" step="0.01" value="0" placeholder="0.0">
            </div>
        </div>
        <div>
            <button id="exportBtn" class="btn btn-outline-primary me-2">Export Data</button>
            <button id="importBtn" class="btn btn-outline-primary me-2">Import Data</button>
            <button id="clearBtn" class="btn btn-outline-danger me-2">Clear</button>
            <button id="testDataBtn" class="btn btn-outline-secondary">Test Data</button>
        </div>
    </div>
    <input type="file" id="fileInput" accept=".csv" style="display: none;">
    <div class="table-responsive">
        <table class="table table-bordered align-middle" id="dataTable">
            <thead>
                <tr>
                    <th class="sticky sticky-header" style="width: 80px;"></th>
                    <th class="sticky-2 sticky-header" style="width: 120px;"></th>
                    <!-- Dynamic column headers here -->
                </tr>
                <tr id="column-controls">
                    <th class="sticky">No.</th>
                    <th class="sticky-2">Height (m)</th>
                    <!-- Dynamic column controls here -->
                </tr>
            </thead>
            <tbody id="tableBody">
                <!-- Dynamic rows here -->
            </tbody>
        </table>
    </div>
    <div class="mt-4">
        <div class="d-flex justify-content-between mb-2">
            <button id="plotDataBtn" class="btn btn-success">Plot Data</button>
            <button id="addRowBtn" class="btn btn-primary">Add Row</button>
        </div>
        <div id="plotPane" class="border bg-white w-100" style="height: 350px; color: #aaa;">
            <span>Plot will appear here.</span>
        </div>
    </div>
</div>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
<script>
// --- Variables ---
const NUM_DATA_COLS = 10;
let dataCols, dataRows;
let chartDatum = 0;
let teamName = '';

// --- Helper functions ---
function getInitialCols() {
    // Wes Anderson themed color palette
    const colors = ['#F1BB7B', '#FD6467', '#5B1A18', '#D67236', '#85D4E3', '#F4B5BD', '#9C964A', '#CDC08C', '#FAD77B', '#4A7C59'];
    return Array.from({length: NUM_DATA_COLS}, (_, i) => ({
        label: '',
        type: 'count',
        color: colors[i]
    }));
}
function getInitialRows() {
    return [createEmptyRow()];
}
function createEmptyRow() {
    return {
        height: '',
        data: Array(NUM_DATA_COLS).fill('')
    };
}

// --- Persistence helpers ---
const STORAGE_KEY = 'millport_transects_data_v1';
function saveToStorage() {
    const payload = {
        dataCols,
        dataRows,
        chartDatum,
        teamName
    };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
}
function loadFromStorage() {
    try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return false;
        const parsed = JSON.parse(raw);
        if (!parsed.dataCols || !parsed.dataRows) return false;
        dataCols = parsed.dataCols;
        dataRows = parsed.dataRows;
        chartDatum = parsed.chartDatum || 0;
        teamName = parsed.teamName || '';
        // Ensure colors exist (for backwards compatibility)
        const colors = ['#F1BB7B', '#FD6467', '#5B1A18', '#D67236', '#85D4E3', '#F4B5BD', '#9C964A', '#CDC08C', '#FAD77B', '#4A7C59'];
        dataCols.forEach((col, i) => {
            if (!col.color) {
                col.color = colors[i];
            }
        });
        document.getElementById('chartDatum').value = chartDatum;
        document.getElementById('teamName').value = teamName;
        return true;
    } catch {
        return false;
    }
}

// --- Plot helpers ---
function clearPlot() {
    Plotly.purge('plotPane');
    document.getElementById('plotPane').innerHTML = '<span>Plot will appear here.</span>';
}

// --- Export/Import helpers ---
function exportToCSV() {
    // Build CSV content
    let csv = [];
    // Header row: No., Height (m), column labels
    let headerRow = ['No.', 'Height (m)'].concat(dataCols.map(col => col.label || ''));
    csv.push(headerRow.join(','));
    // Type row: empty, empty, column types
    let typeRow = ['', ''].concat(dataCols.map(col => col.type));
    csv.push(typeRow.join(','));
    // Data rows
    dataRows.forEach((row, idx) => {
        let dataRow = [idx + 1, row.height].concat(row.data);
        csv.push(dataRow.join(','));
    });
    // Create download
    const csvContent = csv.join('\n');
    const blob = new Blob([csvContent], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'transects.csv';
    a.click();
    URL.revokeObjectURL(url);
}

function importFromCSV(file) {
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const content = e.target.result;
            const lines = content.split(/\r?\n/).filter(line => line.trim());
            if (lines.length < 2) {
                alert('Invalid CSV format: not enough rows');
                return;
            }
            // Parse header row
            const headers = lines[0].split(',').map(h => h.trim());
            if (headers.length < 2 || (headers[0] !== 'No.' && headers[0] !== 'Station') || headers[1] !== 'Height (m)') {
                alert('Invalid CSV format: first two columns must be No. and Height (m)');
                return;
            }
            // Parse type row
            const types = lines[1].split(',').map(t => t.trim());
            // Initialize columns
            dataCols = getInitialCols();
            for (let i = 2; i < headers.length && i - 2 < NUM_DATA_COLS; i++) {
                dataCols[i - 2].label = headers[i] || '';
                const importedType = (types[i] || 'count').toLowerCase();
                // Normalize type to match dropdown values
                dataCols[i - 2].type = importedType === '% cover' || importedType.includes('cover') ? '% cover' : 'count';
            }
            // Parse data rows
            dataRows = [];
            for (let i = 2; i < lines.length; i++) {
                const cols = lines[i].split(',').map(c => c.trim());
                if (cols.length < 2) continue;
                const height = cols[1];
                const data = Array(NUM_DATA_COLS).fill('');
                for (let j = 2; j < cols.length && j - 2 < NUM_DATA_COLS; j++) {
                    data[j - 2] = cols[j] || '';
                }
                dataRows.push({ height, data });
            }
            if (dataRows.length === 0) {
                dataRows = [createEmptyRow()];
            }
            renderTable();
            saveToStorage();
            clearPlot();
            // Auto-plot the imported data
            document.getElementById('plotDataBtn').click();
        } catch (err) {
            alert('Error importing CSV: ' + err.message);
        }
    };
    reader.readAsText(file);
}

// --- Plot Data button logic ---
document.getElementById('plotDataBtn').addEventListener('click', function() {
    const traces = [];
    let colIdx = 0;
    const colLabels = [];
    const datumOffset = parseFloat(document.getElementById('chartDatum').value) || 0;
    const plotTitle = document.getElementById('teamName').value.trim() || 'Kite Diagrams by Column';
    // Find all columns with labels
    for (let i = 0; i < dataCols.length; ++i) {
        const label = dataCols[i].label.trim();
        if (label) colLabels.push(label);
    }
    // Assign each column a unique x-position
    for (let i = 0, plotIdx = 0; i < dataCols.length; ++i) {
        const label = dataCols[i].label.trim();
        if (!label) continue;
        const colType = dataCols[i].type;
        // Gather data for this column
        const heights = [];
        const values = [];
        for (let j = 0; j < dataRows.length; ++j) {
            let h = dataRows[j].height;
            let val = dataRows[j].data[i];
            if (val === '' || isNaN(val) || h === '' || isNaN(h)) continue;
            h = parseFloat(h);
            val = parseFloat(val);
            heights.push(h);
            values.push(val);
        }
        if (heights.length > 0) {
            // Sort by height for a smooth kite/bar
            const zipped = heights.map((h, idx) => [h, values[idx]]).sort((a, b) => a[0] - b[0]);
            const sortedHeights = zipped.map(z => z[0]);
            const sortedValues = zipped.map(z => z[1]);
            const xCenter = plotIdx;
            const maxVal = Math.max(...sortedValues);
            const scale = maxVal > 0 ? 0.4 / maxVal : 0.4;
            if (colType === 'count') {
                // Plot as horizontal bars (no smoothing)
                const xBarRight = sortedValues.map(v => xCenter + v * scale);
                const xBarLeft = sortedValues.map(v => xCenter - v * scale);
                const yWithDatum = sortedHeights.map(h => h + datumOffset);
                traces.push({
                    type: 'scatter',
                    x: [].concat(...yWithDatum.map((h, idx) => [xBarLeft[idx], xBarRight[idx], null])),
                    y: [].concat(...yWithDatum.map((h, idx) => [h, h, null])),
                    mode: 'lines',
                    name: label,
                    line: { shape: 'linear', width: 6, color: dataCols[i].color },
                    hoverinfo: 'skip',
                    showlegend: true,
                    opacity: 0.7
                });
                // Add points for hover info
                traces.push({
                    type: 'scatter',
                    x: xBarRight,
                    y: yWithDatum,
                    mode: 'markers',
                    marker: { size: 6, color: dataCols[i].color },
                    name: label + ' points',
                    showlegend: false,
                    hovertemplate: 'Height (m): %{y}<br>Value: %{customdata}',
                    customdata: sortedValues
                });
            } else {
                // Plot as kite (smoothed polygon)
                const xRight = sortedValues.map(v => xCenter + v * scale);
                const xLeft = sortedValues.map(v => xCenter - v * scale).reverse();
                const yUp = sortedHeights.map(h => h + datumOffset);
                const yDown = [...yUp].reverse();
                const xPoly = xRight.concat(xLeft, [xRight[0]]);
                const yPoly = yUp.concat(yDown, [yUp[0]]);
                traces.push({
                    type: 'scatter',
                    x: xPoly,
                    y: yPoly,
                    fill: 'toself',
                    name: label,
                    mode: 'lines',
                    line: { shape: 'spline', color: dataCols[i].color },
                    fillcolor: dataCols[i].color + '66',
                    hoverinfo: 'skip',
                    showlegend: true,
                    opacity: 0.7
                });
                // Add points for hover info
                traces.push({
                    type: 'scatter',
                    x: xRight,
                    y: yUp,
                    mode: 'markers',
                    marker: { size: 6, color: dataCols[i].color },
                    name: label + ' points',
                    showlegend: false,
                    hovertemplate: 'Height (m): %{y}<br>Value: %{customdata}',
                    customdata: sortedValues
                });
            }
            plotIdx++;
        }
    }
    if (traces.length === 0) {
        Plotly.purge('plotPane');
        document.getElementById('plotPane').innerHTML = '<span>No data to plot.</span>';
        return;
    }
    // Clear any existing plot to ensure clean redraw
    Plotly.purge('plotPane');
    document.getElementById('plotPane').innerHTML = '';
    // Left-justify the plot by setting xaxis range to start at -0.5 and minimal left margin
    const n = colLabels.length;
    Plotly.newPlot('plotPane', traces, {
        title: plotTitle,
        yaxis: { title: 'Height (m)' },
        xaxis: {
            tickvals: colLabels.map((_, i) => i),
            ticktext: colLabels,
            tickangle: -45,
            zeroline: false,
            range: n > 0 ? [-0.5, n - 0.5] : undefined
        },
        margin: { t: 40, b: 100, l: 60, r: 10 },
        height: 340,
        plot_bgcolor: '#fff',
        paper_bgcolor: '#fff',
        showlegend: true,
        autosize: true
    }, {responsive: true});
});

function renderTable() {
    // Render column headers (first row: empty for first two columns)
    const theadRows = document.querySelectorAll('#dataTable thead tr');
    if (theadRows.length >= 2) {
        // First header row: empty for first two columns, then column label inputs
        theadRows[0].innerHTML = `
            <th class="sticky sticky-header" style="width: 80px;"></th>
            <th class="sticky-2 sticky-header" style="width: 120px;"></th>
            ${dataCols.map((col, i) => `
                <th class="sticky-header">
                    <input type="text" class="form-control form-control-sm mb-1" value="${col.label}" data-col-idx="${i}" onchange="onColLabelChange(event)">
                    <input type="color" class="form-control form-control-sm form-control-color" value="${col.color}" data-col-idx="${i}" onchange="onColColorChange(event)" style="height: 30px;">
                </th>`).join('')}
            <th class="sticky-header" style="width: 60px;"></th>
        `;
        // Second header row: No., Height (m), then column type dropdowns
        theadRows[1].innerHTML = `
            <th class="sticky">No.</th>
            <th class="sticky-2">Height (m)</th>
            ${dataCols.map((col, i) => `
                <th>
                    <select class="form-select form-select-sm" data-col-idx="${i}" onchange="onColTypeChange(event)">
                        <option value="count"${col.type==='count'?' selected':''}>count</option>
                        <option value="% cover"${col.type==='% cover'?' selected':''}>% cover</option>
                    </select>
                </th>
            `).join('')}
            <th></th>
        `;
    }
    // Render rows
    const tbody = document.getElementById('tableBody');
    tbody.innerHTML = dataRows.map((row, rowIdx) => `
        <tr>
            <td class="sticky">
                <div class="cell-content">
                    <span>${rowIdx+1}</span>
                    <button class="insert-row-btn" onclick="insertRowAfter(${rowIdx})" title="Insert row after">
                        <i class="bi bi-plus" style="line-height: 1;"></i>
                    </button>
                </div>
            </td>
            <td class="sticky-2">
                <input type="number" class="form-control form-control-sm" min="0" step="0.01" value="${row.height}"
                    data-row-idx="${rowIdx}" onchange="onHeightChange(event)">
            </td>
            ${row.data.map((val, colIdx) => `
                <td>
                    <input type="number" class="form-control form-control-sm" min="0" step="1" value="${val}"
                        data-row-idx="${rowIdx}" data-col-idx="${colIdx}" onchange="onDataCellChange(event)">
                </td>`).join('')}
            <td>
                <button class="btn btn-link btn-sm delete-row-btn" onclick="deleteRow(${rowIdx})" title="Delete row">
                    <i class="bi bi-trash"></i>
                </button>
            </td>
        </tr>
    `).join('');
}

window.onColLabelChange = function(e) {
    const idx = +e.target.getAttribute('data-col-idx');
    dataCols[idx].label = e.target.value;
    renderTable();
    saveToStorage();
};
window.onColColorChange = function(e) {
    const idx = +e.target.getAttribute('data-col-idx');
    dataCols[idx].color = e.target.value;
    saveToStorage();
    // Auto-update plot if there's data to plot
    const hasData = dataCols.some(col => col.label.trim() !== '');
    if (hasData) {
        document.getElementById('plotDataBtn').click();
    }
};
window.onColTypeChange = function(e) {
    const idx = +e.target.getAttribute('data-col-idx');
    dataCols[idx].type = e.target.value;
    renderTable();
    saveToStorage();
    // Auto-update plot if there's data to plot
    const hasData = dataCols.some(col => col.label.trim() !== '');
    if (hasData) {
        setTimeout(() => document.getElementById('plotDataBtn').click(), 10);
    }
};
window.onHeightChange = function(e) {
    const rowIdx = +e.target.getAttribute('data-row-idx');
    let val = e.target.value;
    if (val === '' || isNaN(val)) val = '';
    else val = Math.max(0, parseFloat(val));
    dataRows[rowIdx].height = val;
    saveToStorage();
};
window.onDataCellChange = function(e) {
    const rowIdx = +e.target.getAttribute('data-row-idx');
    const colIdx = +e.target.getAttribute('data-col-idx');
    let val = e.target.value;
    if (val === '' || isNaN(val)) val = '';
    else val = Math.max(0, Math.floor(Number(val)));
    dataRows[rowIdx].data[colIdx] = val;
    saveToStorage();
};
window.deleteRow = function(rowIdx) {
    if (dataRows.length === 1) {
        dataRows = [createEmptyRow()];
    } else {
        dataRows.splice(rowIdx, 1);
    }
    renderTable();
    saveToStorage();
};
window.insertRowAfter = function(rowIdx) {
    const newRow = createEmptyRow();
    dataRows.splice(rowIdx + 1, 0, newRow);
    renderTable();
    saveToStorage();
};
document.getElementById('addRowBtn').addEventListener('click', function() {
    dataRows.push(createEmptyRow());
    renderTable();
    saveToStorage();
});

// Chart datum change handler
document.getElementById('chartDatum').addEventListener('change', function() {
    chartDatum = parseFloat(this.value) || 0;
    saveToStorage();
});

// Team name change handler
document.getElementById('teamName').addEventListener('input', function() {
    teamName = this.value;
    saveToStorage();
});

// Export button logic
document.getElementById('exportBtn').addEventListener('click', function() {
    exportToCSV();
});

// Import button logic
document.getElementById('importBtn').addEventListener('click', function() {
    document.getElementById('fileInput').click();
});

document.getElementById('fileInput').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (file) {
        if (confirm('This will replace all current data. Continue?')) {
            importFromCSV(file);
        }
        // Reset file input
        e.target.value = '';
    }
});

// Clear button logic
document.getElementById('clearBtn').addEventListener('click', function() {
    if (confirm('Are you sure you want to clear the page?')) {
        dataCols = getInitialCols();
        dataRows = getInitialRows();
        renderTable();
        saveToStorage();
        clearPlot();
    }
});

// Test Data button logic
document.getElementById('testDataBtn').addEventListener('click', function() {
    if (!confirm('This will clear the table and insert test data. Continue?')) return;
    dataCols = getInitialCols();
    // Set up columns 1-6
    const labels = ["Semibalanus", "Cthalamus", "Greenish algae", "Brownish algae", "Winkles", "Dogwelks"];
    const types = ["% cover", "% cover", "% cover", "% cover", "count", "count"];
    for (let i = 0; i < 6; ++i) {
        dataCols[i].label = labels[i];
        dataCols[i].type = types[i];
    }
    dataRows = [];
    for (let i = 0; i < 20; ++i) {
        const height = +(i * 0.4).toFixed(2);
        let row = { height: height, data: Array(NUM_DATA_COLS).fill('') };
        // Col 1: normal(mean=height*12.5, sd=10), truncated 0-100, 1dp
        row.data[0] = sampleNormalTrunc(height*12.5, 10, 0, 100, 1);
        // Col 2: normal(mean=8-height*12.5, sd=10), truncated 0-100, 1dp
        row.data[1] = sampleNormalTrunc(8-height*12.5, 10, 0, 100, 1);
        // Col 3: normal(mean=height*12.5, sd=10), truncated 0-100, 1dp
        row.data[2] = sampleNormalTrunc(height*12.5, 10, 0, 100, 1);
        // Col 4: normal(mean=8-height*12.5, sd=10), truncated 0-100, 1dp
        row.data[3] = sampleNormalTrunc(8-height*12.5, 10, 0, 100, 1);
        // Col 5: poisson(mean=10)
        row.data[4] = samplePoisson(10);
        // Col 6: poisson(mean=height)
        row.data[5] = samplePoisson(height);
        dataRows.push(row);
    }
    if (dataRows.length === 0) dataRows = [createEmptyRow()];
    renderTable();
    saveToStorage();
    // Auto-plot the test data
    document.getElementById('plotDataBtn').click();
});

// Helper: sample from normal distribution, truncated, with decimal places
function sampleNormalTrunc(mean, sd, min, max, decimals) {
    // Clamp mean to [min, max] to avoid impossible sampling
    mean = Math.max(min, Math.min(max, mean));
    let val;
    let attempts = 0, maxAttempts = 100;
    do {
        val = mean + sd * boxMullerRandom();
        attempts++;
        if (attempts > maxAttempts) {
            // If can't find a value, return closest bound
            return Number(Math.max(min, Math.min(max, val)).toFixed(decimals));
        }
    } while (val < min || val > max);
    return Number(val.toFixed(decimals));
}
// Helper: standard normal
function boxMullerRandom() {
    let u = 0, v = 0;
    while(u === 0) u = Math.random();
    while(v === 0) v = Math.random();
    return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
}
// Helper: sample from Poisson distribution
function samplePoisson(lambda) {
    let L = Math.exp(-lambda);
    let k = 0;
    let p = 1;
    do {
        k++;
        p *= Math.random();
    } while (p > L);
    return k - 1;
}

// Initialize
if (!loadFromStorage()) {
    dataCols = getInitialCols();
    dataRows = getInitialRows();
} else {
    // Auto-plot the loaded data
    setTimeout(() => document.getElementById('plotDataBtn').click(), 100);
}
renderTable();
</script>
</body>
</html>
