<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transect Data Entry</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css" rel="stylesheet">
    <style>
        :root {
            --col-width-rownum: 45px;
            --col-width-height: 64px;
            --col-width-length: 64px;
            --col-width-data: 120px;
            --col-width-action: 40px;
            --row-height-header-1: 40px;
            --row-height-header-2: 40px;
            --row-height-header-3: 40px;
            --row-height-data: auto;
            --plot-pane-height: 450px;
            --profile-plot-height: 180px;
        }
        .table-responsive {
            max-height: 385px;
            overflow-x: auto;
            overflow-y: auto;
            position: relative;
            display: block;
            overflow-anchor: none;
        }
        #dataTable {
            table-layout: fixed !important;
            position: relative;
            margin-bottom: 0;
            display: table;
            border-collapse: separate !important;
            border-spacing: 0 !important;
        }
        #dataTable th:not(.sticky):not(.sticky-2):not(.sticky-3):not(:last-child),
        #dataTable td:not(.sticky):not(.sticky-2):not(.sticky-3):not(:last-child) {
            width: var(--col-width-data);
            min-width: var(--col-width-data);
            max-width: var(--col-width-data);
        }
        th.sticky, td.sticky {
            position: sticky !important;
            left: 0 !important;
            background: #fff;
            z-index: 10002;
            width: var(--col-width-rownum);
            min-width: var(--col-width-rownum);
            max-width: var(--col-width-rownum);
            box-shadow: 0.5px 0 0 0 #dee2e6;
        }
        th.sticky-2, td.sticky-2 {
            position: sticky !important;
            left: var(--col-width-rownum) !important;
            background: #fff;
            z-index: 10002;
            width: var(--col-width-height);
            min-width: var(--col-width-height);
            max-width: var(--col-width-height);
            box-shadow: 0.5px 0 0 0 #dee2e6;
        }
        th.sticky-3, td.sticky-3 {
            position: sticky !important;
            left: calc(var(--col-width-rownum) + var(--col-width-height)) !important;
            background: #fff;
            z-index: 10002;
            width: var(--col-width-length);
            min-width: var(--col-width-length);
            max-width: var(--col-width-length);
            box-shadow: 0.5px 0 0 0 #dee2e6;
        }
        tbody tr:hover td.sticky,
        tbody tr:hover td.sticky-2,
        tbody tr:hover td.sticky-3 {
            z-index: 10002;
        }
        th.sticky.sticky-header,
        th.sticky-2.sticky-header,
        th.sticky-3.sticky-header {
            z-index: 10003 !important;
        }
        td.sticky {
            padding: 0.25rem !important;
        }
        td.sticky-2 {
            padding: 0.25rem !important;
        }
        td.sticky-2 input {
            font-size: 0.875rem;
        }
        td.sticky-3 {
            padding: 0.25rem !important;
        }
        td.sticky-3 input {
            font-size: 0.875rem;
        }
        td.sticky, td.sticky-2, td.sticky-3 {
            overflow: visible;
        }
        .fill-btn-container {
            display: flex;
            align-items: flex-end;
            justify-content: center;
            width: 100%;
            height: 100%;
            padding-bottom: 4px;
            box-sizing: border-box;
        }
        .fill-btn {
            font-size: 0.75rem;
            padding: 2px 6px;
        }
        th.sticky-header:has(.fill-btn-container) {
            vertical-align: bottom;
        }
        th.sticky-header {
            position: sticky !important;
            top: 0 !important;
            background: #f8f9fa !important;
            z-index: 10001;
            border: 0.5px solid #dee2e6;
            height: calc(var(--row-height-header-1) + var(--row-height-header-2) + var(--row-height-header-3)) !important;
            min-height: calc(var(--row-height-header-1) + var(--row-height-header-2) + var(--row-height-header-3)) !important;
            max-height: calc(var(--row-height-header-1) + var(--row-height-header-2) + var(--row-height-header-3)) !important;
            box-sizing: border-box !important;
            padding: 0 !important;
            vertical-align: top !important;
        }
        th.sticky-header .header-row-1,
        th.sticky-header .header-row-2,
        th.sticky-header .header-row-3 {
            width: 100%;
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.5rem;
        }
        th.sticky-header .header-row-1 {
            height: var(--row-height-header-1);
            min-height: var(--row-height-header-1);
            max-height: var(--row-height-header-1);
        }
        th.sticky-header .header-row-2 {
            height: var(--row-height-header-2);
            min-height: var(--row-height-header-2);
            max-height: var(--row-height-header-2);
        }
        th.sticky-header .header-row-3 {
            height: var(--row-height-header-3);
            min-height: var(--row-height-header-3);
            max-height: var(--row-height-header-3);
        }
        .toolbar {
            margin-bottom: 1rem;
        }
        .delete-row-btn {
            color: #dc3545;
            cursor: pointer;
        }
        .table thead th {
            vertical-align: middle;
        }
        .table thead {
            display: table-header-group;
        }
        .table thead tr {
            display: table-row;
        }
        .table thead tr th {
            height: calc(var(--row-height-header-1) + var(--row-height-header-2) + var(--row-height-header-3)) !important;
            min-height: calc(var(--row-height-header-1) + var(--row-height-header-2) + var(--row-height-header-3)) !important;
            max-height: calc(var(--row-height-header-1) + var(--row-height-header-2) + var(--row-height-header-3)) !important;
        }
        .table tbody td {
            vertical-align: middle;
            overflow: visible;
            border: 0.5px solid #dee2e6;
            height: var(--row-height-data);
        }
        .table tbody tr {
            height: var(--row-height-data) !important;
            min-height: var(--row-height-data) !important;
            max-height: var(--row-height-data) !important;
            overflow: visible;
        }
        td.sticky {
            padding-left: 5px !important;
            overflow: visible !important;
            position: relative;
        }
        td.sticky .cell-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            overflow: visible;
            position: relative;
        }
        td.sticky .cell-content::after {
            content: '';
            position: absolute;
            top: 50%;
            left: -10px;
            right: -10px;
            height: 200%;
            z-index: 8;
        }
        td.sticky .cell-content:hover .insert-row-btn {
            opacity: 1;
            z-index: 10002;
        }
        td.sticky .cell-content span {
            font-size: 0.875rem;
        }
        td.sticky {
            overflow: visible;
        }
        tbody tr {
            position: relative;
            z-index: 1;
            overflow: visible;
        }
        tbody tr:hover {
            z-index: 10001;
        }
        tbody tr:hover td:not(.sticky):not(.sticky-2):not(.sticky-3) {
            position: relative;
            z-index: 100;
        }
        tbody tr:hover td.sticky,
        tbody tr:hover td.sticky-2,
        tbody tr:hover td.sticky-3 {
            z-index: 10005;
        }
        tbody {
            position: relative;
            display: table-row-group;
            overflow: visible;
        }
        .insert-row-btn {
            position: absolute;
            bottom: 0;
            left: 30px;
            width: 20px;
            height: 20px;
            padding: 0;
            border-radius: 50%;
            background: #28a745;
            color: white;
            border: 2px solid white;
            font-size: 12px;
            line-height: 16px;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 10006;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            pointer-events: auto;
            transform: translate(-50%, 50%);
        }
        .insert-row-btn:hover {
            background: #218838;
        }
        tbody tr:hover .insert-row-btn {
            opacity: 1;
        }
        th.sticky .header-insert-btn {
            position: absolute;
            bottom: 0;
            left: 30px;
            width: 20px;
            height: 20px;
            padding: 0;
            border-radius: 50%;
            background: #28a745;
            color: white;
            border: 2px solid white;
            font-size: 12px;
            line-height: 16px;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 10002;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            pointer-events: auto;
            transform: translate(-50%, 50%);
        }
        th.sticky:hover .header-insert-btn {
            opacity: 1;
        }
        th.sticky .header-insert-btn:hover {
            background: #218838;
        }
        .resize-handle {
            height: 8px;
            background: #e9ecef;
            cursor: ns-resize;
            border-top: 0.5px solid #dee2e6;
            border-bottom: 0.5px solid #dee2e6;
            position: relative;
            user-select: none;
        }
        .resize-handle:hover {
            background: #ced4da;
        }
        .resize-handle::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 3px;
            background: #6c757d;
            border-radius: 2px;
        }
        /* Modal z-index fix for sticky headers */
        .modal-backdrop {
            z-index: 10100 !important;
        }
        .modal {
            z-index: 10200 !important;
        }
        /* Hide number input spinners */
        input[type=number]::-webkit-inner-spin-button,
        input[type=number]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type=number] {
            -moz-appearance: textfield;
        }
        /* Table header cell styles */
        .table-header-cell {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            font-size: 0.875rem;
            font-weight: 600;
            color: #212529;
            vertical-align: middle;
            background: #f8f9fa;
            padding: 0.5rem;
        }
        /* Table data cell styles */
        .table-data-cell {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            font-size: 0.875rem;
            font-weight: 400;
            color: #212529;
            vertical-align: middle;
            padding: 0.25rem;
        }
        /* Input fields in cells */
        .table-cell-input {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            font-size: 0.875rem;
            font-weight: 400;
        }
        /* Row number cell styles */
        .row-number-cell {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            font-size: 0.875rem;
            font-weight: 500;
            color: #6c757d;
        }
    </style>
</head>
<body class="bg-light">
<div class="container py-4" style="max-width: 1240px;">
    <div class="toolbar d-flex justify-content-between align-items-center mb-2">
        <div class="d-flex align-items-center">
            <h4 class="mb-0 me-3">Transect Data Entry</h4>
            <div class="d-flex align-items-center me-3">
                <label for="teamName" class="me-2 mb-0">Team:</label>
                <input type="text" id="teamName" class="form-control form-control-sm" style="width: 150px;" placeholder="Team name">
            </div>
            <div class="d-flex align-items-center">
                <label for="chartDatum" class="me-2 mb-0">Chart datum:</label>
                <input type="number" id="chartDatum" class="form-control form-control-sm" style="width: 100px;" step="0.01" value="0" placeholder="0.0">
            </div>
        </div>
        <div>
            <button id="exportBtn" class="btn btn-outline-primary me-2">Export Data</button>
            <button id="importBtn" class="btn btn-outline-primary me-2">Import Data</button>
            <button id="clearBtn" class="btn btn-outline-danger me-2">Clear</button>
            <button id="testDataBtn" class="btn btn-outline-secondary">Test Data</button>
        </div>
    </div>
    <input type="file" id="fileInput" accept=".csv" style="display: none;">
    <div class="table-responsive" style="overflow-x: auto;">
        <table class="table table-bordered align-middle" id="dataTable" style="table-layout: fixed;">
            <thead>
                <tr>
                    <th class="sticky sticky-header table-header-cell" style="width: var(--col-width-rownum);">
                        <div class="header-row-1"></div>
                        <div class="header-row-2"></div>
                        <div class="header-row-3">No.</div>
                        <button class="header-insert-btn" onclick="insertRowAtTop()" title="Insert row at top">
                            <i class="bi bi-plus" style="line-height: 1;"></i>
                        </button>
                    </th>
                    <th class="sticky-2 sticky-header table-header-cell" style="width: var(--col-width-height);">
                        <div class="header-row-1"></div>
                        <div class="header-row-2">
                            <div class="fill-btn-container">
                                <button id="fillHeightsBtn" class="btn btn-outline-warning btn-sm fill-btn" onclick="fillHeights()">Fill Down</button>
                            </div>
                        </div>
                        <div class="header-row-3">Height</div>
                    </th>
                    <th class="sticky-3 sticky-header table-header-cell" style="width: var(--col-width-length);">
                        <div class="header-row-1"></div>
                        <div class="header-row-2"></div>
                        <div class="header-row-3">Length</div>
                    </th>
                    <!-- Dynamic column headers here -->
                </tr>
            </thead>
            <tbody id="tableBody">
                <!-- Dynamic rows here -->
            </tbody>
        </table>
    </div>
    <div class="resize-handle" id="resizeHandle"></div>
    <div class="mt-2">
        <div class="d-flex justify-content-between mb-2">
            <button id="plotDataBtn" class="btn btn-success">Plot Data</button>
        </div>
        <div id="plotPane" class="border bg-white w-100" style="height: var(--plot-pane-height); color: #aaa;">
            <span>Plot will appear here.</span>
        </div>
        <div id="profilePlotPane" class="border bg-white w-100 mt-2" style="height: var(--profile-plot-height); color: #aaa;">
            <span>Shore profile will appear here.</span>
        </div>
    </div>
</div>

<!-- Fill Heights Modal -->
<div class="modal fade" id="fillHeightsModal" tabindex="-1" aria-labelledby="fillHeightsModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="fillHeightsModalLabel">Fill Heights</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p class="text-muted">Enter the starting height and increment to automatically fill all height values in the table.</p>
                <div class="mb-3">
                    <label for="startHeight" class="form-label">Start Height</label>
                    <input type="number" class="form-control" id="startHeight" step="0.01" placeholder="e.g., 0">
                </div>
                <div class="mb-3">
                    <label for="heightIncrement" class="form-label">Increment</label>
                    <input type="number" class="form-control" id="heightIncrement" step="0.01" placeholder="e.g., 0.5">
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="applyFillHeights">Apply</button>
            </div>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
<script>
// --- Variables ---
const NUM_DATA_COLS = 8;
let dataCols, dataRows;
let chartDatum = 0;
let teamName = '';

const DEFAULT_COLOURS = ['#F1BB7B', '#FD6467', '#5B1A18', '#D67236', '#85D4E3', '#F4B5BD', '#9C964A', '#CDC08C'];

// --- Helper functions ---
function getInitialCols() {
    // Wes Anderson themed color palette
    return Array.from({length: NUM_DATA_COLS}, (_, i) => ({
        label: '',
        type: 'count',
        color: DEFAULT_COLOURS[i]
    }));
}
function getInitialRows() {
    return [createEmptyRow()];
}
function createEmptyRow() {
    return {
        height: '',
        length: '',
        data: Array(NUM_DATA_COLS).fill('')
    };
}

// --- Persistence helpers ---
const STORAGE_KEY = 'millport_transects_data_v1';
function saveToStorage() {
    const payload = {
        dataCols,
        dataRows,
        chartDatum,
        teamName
    };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
}
function loadFromStorage() {
    try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return false;
        const parsed = JSON.parse(raw);
        if (!parsed.dataCols || !parsed.dataRows) return false;
        dataCols = parsed.dataCols;
        dataRows = parsed.dataRows;
        chartDatum = parsed.chartDatum || 0;
        teamName = parsed.teamName || '';
        // Ensure colors exist (for backwards compatibility)
        dataCols.forEach((col, i) => {
            if (!col.color) {
                col.color = DEFAULT_COLOURS[i];
            }
        });
        // Ensure length field exists (for backwards compatibility)
        dataRows.forEach(row => {
            if (row.length === undefined) {
                row.length = '';
            }
        });
        document.getElementById('chartDatum').value = chartDatum;
        document.getElementById('teamName').value = teamName;
        return true;
    } catch {
        return false;
    }
}

// --- Plot helpers ---
function clearPlot() {
    Plotly.purge('plotPane');
    document.getElementById('plotPane').innerHTML = '<span>Plot will appear here.</span>';
    Plotly.purge('profilePlotPane');
    document.getElementById('profilePlotPane').innerHTML = '<span>Shore profile will appear here.</span>';
}

// --- Export/Import helpers ---
function exportToCSV() {
    // Build CSV content
    let csv = [];
    // Header row: No., Height, Length, column labels
    let headerRow = ['No.', 'Height', 'Length'].concat(dataCols.map(col => col.label || ''));
    csv.push(headerRow.join(','));
    // Type row: empty, empty, empty, column types
    let typeRow = ['', '', ''].concat(dataCols.map(col => col.type));
    csv.push(typeRow.join(','));
    // Data rows
    dataRows.forEach((row, idx) => {
        let dataRow = [idx + 1, row.height, row.length].concat(row.data);
        csv.push(dataRow.join(','));
    });
    // Create download
    const csvContent = csv.join('\n');
    const blob = new Blob([csvContent], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'transects.csv';
    a.click();
    URL.revokeObjectURL(url);
}

function importFromCSV(file) {
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const content = e.target.result;
            const lines = content.split(/\r?\n/).filter(line => line.trim());
            if (lines.length < 2) {
                alert('Invalid CSV format: not enough rows');
                return;
            }
            // Parse header row
            const headers = lines[0].split(',').map(h => h.trim());
            if (headers.length < 2) {
                alert('Invalid CSV format: must have at least 2 columns');
                return;
            }
            // Check if this is the new format (with Length column) or old format
            const hasLengthColumn = headers.length >= 3 && (headers[2].toLowerCase() === 'length' || headers.length > 10);
            const dataStartCol = hasLengthColumn ? 3 : 2;
            
            // Parse type row
            const types = lines[1].split(',').map(t => t.trim());
            // Initialize columns
            dataCols = getInitialCols();
            for (let i = dataStartCol; i < headers.length && i - dataStartCol < NUM_DATA_COLS; i++) {
                dataCols[i - dataStartCol].label = headers[i] || '';
                const importedType = (types[i] || 'count').toLowerCase();
                // Normalize type to match dropdown values
                dataCols[i - dataStartCol].type = importedType === '% cover' || importedType.includes('cover') ? '% cover' : 'count';
            }
            // Parse data rows
            dataRows = [];
            for (let i = 2; i < lines.length; i++) {
                const cols = lines[i].split(',').map(c => c.trim());
                if (cols.length < 2) continue;
                const height = cols[1];
                const length = hasLengthColumn && cols.length > 2 ? cols[2] : '';
                const data = Array(NUM_DATA_COLS).fill('');
                for (let j = dataStartCol; j < cols.length && j - dataStartCol < NUM_DATA_COLS; j++) {
                    data[j - dataStartCol] = cols[j] || '';
                }
                dataRows.push({ height, length, data });
            }
            if (dataRows.length === 0) {
                dataRows = [createEmptyRow()];
            }
            renderTable();
            saveToStorage();
            clearPlot();
            // Auto-plot the imported data
            document.getElementById('plotDataBtn').click();
        } catch (err) {
            alert('Error importing CSV: ' + err.message);
        }
    };
    reader.readAsText(file);
}

// --- Plot Data button logic ---
document.getElementById('plotDataBtn').addEventListener('click', function() {
    const traces = [];
    let colIdx = 0;
    const colLabels = [];
    const datumOffset = parseFloat(document.getElementById('chartDatum').value) || 0;
    const plotTitle = document.getElementById('teamName').value.trim() || 'Kite Diagrams by Column';
    
    // Find all columns with labels
    for (let i = 0; i < dataCols.length; ++i) {
        const label = dataCols[i].label.trim();
        if (label) colLabels.push(label);
    }
    // Assign each column a unique x-position
    for (let i = 0, plotIdx = 0; i < dataCols.length; ++i) {
        const label = dataCols[i].label.trim();
        if (!label) continue;
        const colType = dataCols[i].type;
        // Gather data for this column
        const heights = [];
        const values = [];
        for (let j = 0; j < dataRows.length; ++j) {
            let h = dataRows[j].height;
            let val = dataRows[j].data[i];
            if (val === '' || isNaN(val) || h === '' || isNaN(h)) continue;
            h = parseFloat(h);
            val = parseFloat(val);
            heights.push(h);
            values.push(val);
        }
        if (heights.length > 0) {
            // Sort by height for a smooth kite/bar
            const zipped = heights.map((h, idx) => [h, values[idx]]).sort((a, b) => a[0] - b[0]);
            const sortedHeights = zipped.map(z => z[0]);
            const sortedValues = zipped.map(z => z[1]);
            const xCenter = plotIdx + 0.4;
            const maxVal = Math.max(...sortedValues);
            const scale = maxVal > 0 ? 0.4 / maxVal : 0.4;
            if (colType === 'count') {
                // Plot as horizontal bars (no smoothing)
                const xBarRight = sortedValues.map(v => xCenter + v * scale);
                const xBarLeft = sortedValues.map(v => xCenter - v * scale);
                const yWithDatum = sortedHeights.map(h => h + datumOffset);
                traces.push({
                    type: 'scatter',
                    x: [].concat(...yWithDatum.map((h, idx) => [xBarLeft[idx], xBarRight[idx], null])),
                    y: [].concat(...yWithDatum.map((h, idx) => [h, h, null])),
                    mode: 'lines',
                    name: label,
                    line: { shape: 'linear', width: 6, color: dataCols[i].color },
                    hoverinfo: 'skip',
                    showlegend: true,
                    opacity: 0.7
                });
                // Add points for hover info
                traces.push({
                    type: 'scatter',
                    x: xBarRight,
                    y: yWithDatum,
                    mode: 'markers',
                    marker: { size: 6, color: dataCols[i].color },
                    name: label + ' points',
                    showlegend: false,
                    hovertemplate: 'Height: %{y}<br>Value: %{customdata}',
                    customdata: sortedValues
                });
            } else {
                // Plot as kite (smoothed polygon)
                const xRight = sortedValues.map(v => xCenter + v * scale);
                const xLeft = sortedValues.map(v => xCenter - v * scale).reverse();
                const yUp = sortedHeights.map(h => h + datumOffset);
                const yDown = [...yUp].reverse();
                const xPoly = xRight.concat(xLeft, [xRight[0]]);
                const yPoly = yUp.concat(yDown, [yUp[0]]);
                traces.push({
                    type: 'scatter',
                    x: xPoly,
                    y: yPoly,
                    fill: 'toself',
                    name: label,
                    mode: 'lines',
                    line: { shape: 'spline', color: dataCols[i].color },
                    fillcolor: dataCols[i].color + '66',
                    hoverinfo: 'skip',
                    showlegend: true,
                    opacity: 0.7
                });
                // Add points for hover info
                traces.push({
                    type: 'scatter',
                    x: xRight,
                    y: yUp,
                    mode: 'markers',
                    marker: { size: 6, color: dataCols[i].color },
                    name: label + ' points',
                    showlegend: false,
                    hovertemplate: 'Height: %{y}<br>Value: %{customdata}',
                    customdata: sortedValues
                });
            }
            plotIdx++;
        }
    }
    if (traces.length === 0) {
        Plotly.purge('plotPane');
        document.getElementById('plotPane').innerHTML = '<span>No data to plot.</span>';
        Plotly.purge('profilePlotPane');
        document.getElementById('profilePlotPane').innerHTML = '<span>No height/length data to plot.</span>';
        return;
    }
    // Clear any existing plot to ensure clean redraw
    Plotly.purge('plotPane');
    document.getElementById('plotPane').innerHTML = '';
    // Left-justify the plot by setting xaxis range to start at -0.5 and minimal left margin
    const n = colLabels.length;
    Plotly.newPlot('plotPane', traces, {
        title: plotTitle,
        yaxis: { title: 'Absolute Height (m)' },
        xaxis: {
            tickvals: colLabels.map((_, i) => i + 0.4),
            ticktext: colLabels,
            tickangle: -45,
            zeroline: false,
            showline: false,
            range: n > 0 ? [-0.1, n + 0.3] : [-0.1, 0.7]
        },
        margin: { t: 40, b: 100, l: 60, r: 10 },
        height: 440,
        plot_bgcolor: '#fff',
        paper_bgcolor: '#fff',
        showlegend: true,
        autosize: true
    }, {responsive: true});
    
    // Plot shore profile separately
    const profileHeights = [];
    const profileDistances = [];
    for (let j = 0; j < dataRows.length; ++j) {
        let h = dataRows[j].height;
        let len = dataRows[j].length;
        if (h !== '' && !isNaN(h) && len !== '' && !isNaN(len)) {
            h = parseFloat(h);
            len = parseFloat(len);
            // Calculate horizontal distance: sqrt(length^2 - height^2)
            const distance = Math.sqrt(len * len - h * h);
            profileHeights.push(h + datumOffset);
            profileDistances.push(distance);
        }
    }
    
    if (profileHeights.length > 0) {
        // Sort by distance (x-axis)
        const zipped = profileDistances.map((dist, idx) => [dist, profileHeights[idx]]).sort((a, b) => a[0] - b[0]);
        const sortedDistances = zipped.map(z => z[0]);
        const sortedHeights = zipped.map(z => z[1]);
        
        // Create filled area from minimum y to profile line
        const minHeight = Math.min(...sortedHeights);
        const xPoly = [sortedDistances[0]].concat(sortedDistances, [sortedDistances[sortedDistances.length - 1]]);
        const yPoly = [minHeight].concat(sortedHeights, [minHeight]);
        
        Plotly.newPlot('profilePlotPane', [{
            type: 'scatter',
            x: xPoly,
            y: yPoly,
            fill: 'toself',
            mode: 'lines',
            line: { shape: 'linear', color: '#8B7355', width: 2 },
            fillcolor: 'rgba(139, 115, 85, 0.5)',
            hovertemplate: 'Distance: %{x:.2f}<br>Height: %{y:.2f}<extra></extra>',
            showlegend: false
        }], {
            title: 'Shore Profile',
            xaxis: { title: 'Distance (m)', zeroline: false },
            yaxis: { title: 'Absolute Height (m)', zeroline: false },
            margin: { t: 40, b: 50, l: 60, r: 10 },
            height: 170,
            plot_bgcolor: '#fff',
            paper_bgcolor: '#fff',
            autosize: true
        }, {responsive: true});
    } else {
        Plotly.purge('profilePlotPane');
        document.getElementById('profilePlotPane').innerHTML = '<span>No height/length data to plot.</span>';
    }
});

function renderTable() {
    // Render single header row with 3 internal containers per cell
    const theadRows = document.querySelectorAll('#dataTable thead tr');
    if (theadRows.length >= 1) {
        theadRows[0].innerHTML = `
            <th class="sticky sticky-header table-header-cell" style="width: var(--col-width-rownum);">
                <div class="header-row-1"></div>
                <div class="header-row-2"></div>
                <div class="header-row-3">No.</div>
                <button class="header-insert-btn" onclick="insertRowAtTop()" title="Insert row at top">
                    <i class="bi bi-plus" style="line-height: 1;"></i>
                </button>
            </th>
            <th class="sticky-2 sticky-header table-header-cell" style="width: var(--col-width-height);">
                <div class="header-row-1"></div>
                <div class="header-row-2">
                    <div class="fill-btn-container">
                        <button id="fillHeightsBtn" class="btn btn-outline-warning btn-sm fill-btn" onclick="fillHeights()">Fill Down </button>
                    </div>
                </div>
                <div class="header-row-3">Height</div>
            </th>
            <th class="sticky-3 sticky-header table-header-cell" style="width: var(--col-width-length);">
                <div class="header-row-1"></div>
                <div class="header-row-2"></div>
                <div class="header-row-3">Length</div>
            </th>
            ${dataCols.map((col, i) => `
                <th class="sticky-header table-header-cell" style="width: var(--col-width-data);">
                    <div class="header-row-1">
                        <input type="text" class="form-control form-control-sm table-cell-input" value="${col.label}" data-col-idx="${i}" onchange="onColLabelChange(event)">
                    </div>
                    <div class="header-row-2">
                        <input type="color" class="form-control form-control-sm form-control-color" value="${col.color}" data-col-idx="${i}" onchange="onColColorChange(event)" style="height: 26px;">
                    </div>
                    <div class="header-row-3">
                        <select class="form-select form-select-sm table-cell-input" data-col-idx="${i}" onchange="onColTypeChange(event)">
                            <option value="count"${col.type==='count'?' selected':''}>count</option>
                            <option value="% cover"${col.type==='% cover'?' selected':''}>% cover</option>
                        </select>
                    </div>
                </th>
            `).join('')}
            <th class="sticky-header table-header-cell" style="width: var(--col-width-action);">
                <div class="header-row-1"></div>
                <div class="header-row-2"></div>
                <div class="header-row-3"></div>
            </th>
        `;
    }
    // Render rows
    const tbody = document.getElementById('tableBody');
    tbody.innerHTML = dataRows.map((row, rowIdx) => `
        <tr>
            <td class="sticky table-data-cell">
                <div class="cell-content">
                    <span class="row-number-cell">${rowIdx+1}</span>
                </div>
                <button class="insert-row-btn" onclick="insertRowAfter(${rowIdx})" title="Insert row after">
                    <i class="bi bi-plus" style="line-height: 1;"></i>
                </button>
            </td>
            <td class="sticky-2 table-data-cell">
                <input type="number" class="form-control form-control-sm table-cell-input" min="0" step="0.01" value="${row.height}"
                    data-row-idx="${rowIdx}" onchange="onHeightChange(event)">
            </td>
            <td class="sticky-3 table-data-cell">
                <input type="number" class="form-control form-control-sm table-cell-input" min="0" step="0.01" value="${row.length}"
                    data-row-idx="${rowIdx}" onchange="onLengthChange(event)">
            </td>
            ${row.data.map((val, colIdx) => `
                <td class="table-data-cell">
                    <input type="number" class="form-control form-control-sm table-cell-input" min="0" step="1" value="${val}"
                        data-row-idx="${rowIdx}" data-col-idx="${colIdx}" onchange="onDataCellChange(event)">
                </td>`).join('')}
            <td class="table-data-cell">
                <button class="btn btn-link btn-sm delete-row-btn" onclick="deleteRow(${rowIdx})" title="Delete row">
                    <i class="bi bi-trash"></i>
                </button>
            </td>
        </tr>
    `).join('');
}

window.onColLabelChange = function(e) {
    const idx = +e.target.getAttribute('data-col-idx');
    dataCols[idx].label = e.target.value;
    renderTable();
    saveToStorage();
};
window.onColColorChange = function(e) {
    const idx = +e.target.getAttribute('data-col-idx');
    dataCols[idx].color = e.target.value;
    saveToStorage();
    // Auto-update plot if there's data to plot
    const hasData = dataCols.some(col => col.label.trim() !== '');
    if (hasData) {
        document.getElementById('plotDataBtn').click();
    }
};
window.onColTypeChange = function(e) {
    const idx = +e.target.getAttribute('data-col-idx');
    dataCols[idx].type = e.target.value;
    renderTable();
    saveToStorage();
    // Auto-update plot if there's data to plot
    const hasData = dataCols.some(col => col.label.trim() !== '');
    if (hasData) {
        setTimeout(() => document.getElementById('plotDataBtn').click(), 10);
    }
};
window.onHeightChange = function(e) {
    const rowIdx = +e.target.getAttribute('data-row-idx');
    let val = e.target.value;
    if (val === '' || isNaN(val)) val = '';
    else val = Math.max(0, parseFloat(val));
    dataRows[rowIdx].height = val;
    saveToStorage();
};
window.onLengthChange = function(e) {
    const rowIdx = +e.target.getAttribute('data-row-idx');
    let val = e.target.value;
    if (val === '' || isNaN(val)) val = '';
    else val = Math.max(0, parseFloat(val));
    dataRows[rowIdx].length = val;
    saveToStorage();
};
window.onDataCellChange = function(e) {
    const rowIdx = +e.target.getAttribute('data-row-idx');
    const colIdx = +e.target.getAttribute('data-col-idx');
    let val = e.target.value;
    if (val === '' || isNaN(val)) val = '';
    else val = Math.max(0, Math.floor(Number(val)));
    dataRows[rowIdx].data[colIdx] = val;
    saveToStorage();
};
window.deleteRow = function(rowIdx) {
    if (dataRows.length === 1) {
        dataRows = [createEmptyRow()];
    } else {
        dataRows.splice(rowIdx, 1);
    }
    renderTable();
    saveToStorage();
};
window.insertRowAfter = function(rowIdx) {
    const newRow = createEmptyRow();
    dataRows.splice(rowIdx + 1, 0, newRow);
    renderTable();
    saveToStorage();
};
window.insertRowAtTop = function() {
    const newRow = createEmptyRow();
    dataRows.unshift(newRow);
    renderTable();
    saveToStorage();
};
window.fillHeights = function() {
    const modal = new bootstrap.Modal(document.getElementById('fillHeightsModal'));
    modal.show();
};

// Handle fill heights apply button
document.getElementById('applyFillHeights').addEventListener('click', function() {
    const startHeight = parseFloat(document.getElementById('startHeight').value);
    const increment = parseFloat(document.getElementById('heightIncrement').value);
    
    if (isNaN(startHeight)) {
        alert('Please enter a valid number for start height');
        return;
    }
    
    if (isNaN(increment)) {
        alert('Please enter a valid number for increment');
        return;
    }
    
    // Fill heights
    for (let i = 0; i < dataRows.length; i++) {
        dataRows[i].height = +(startHeight + i * increment).toFixed(2);
    }
    
    renderTable();
    saveToStorage();
    
    // Auto-update plot if there's data to plot
    const hasData = dataCols.some(col => col.label.trim() !== '');
    if (hasData) {
        document.getElementById('plotDataBtn').click();
    }
    
    // Close modal
    const modal = bootstrap.Modal.getInstance(document.getElementById('fillHeightsModal'));
    modal.hide();
    
    // Clear inputs for next time
    document.getElementById('startHeight').value = '';
    document.getElementById('heightIncrement').value = '';
});

// Chart datum change handler
document.getElementById('chartDatum').addEventListener('change', function() {
    chartDatum = parseFloat(this.value) || 0;
    saveToStorage();
});

// Team name change handler
document.getElementById('teamName').addEventListener('input', function() {
    teamName = this.value;
    saveToStorage();
});

// Table resize handle
let isResizing = false;
const resizeHandle = document.getElementById('resizeHandle');
const tableResponsive = document.querySelector('.table-responsive');

resizeHandle.addEventListener('mousedown', function(e) {
    isResizing = true;
    document.body.style.cursor = 'ns-resize';
    document.body.style.userSelect = 'none';
    e.preventDefault();
});

document.addEventListener('mousemove', function(e) {
    if (!isResizing) return;
    
    const containerTop = tableResponsive.getBoundingClientRect().top;
    const newHeight = e.clientY - containerTop;
    
    // Set minimum and maximum heights
    if (newHeight >= 200 && newHeight <= 800) {
        tableResponsive.style.maxHeight = newHeight + 'px';
    }
});

document.addEventListener('mouseup', function() {
    if (isResizing) {
        isResizing = false;
        document.body.style.cursor = '';
        document.body.style.userSelect = '';
    }
});

// Export button logic
document.getElementById('exportBtn').addEventListener('click', function() {
    exportToCSV();
});

// Import button logic
document.getElementById('importBtn').addEventListener('click', function() {
    document.getElementById('fileInput').click();
});

document.getElementById('fileInput').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (file) {
        if (confirm('This will replace all current data. Continue?')) {
            importFromCSV(file);
        }
        // Reset file input
        e.target.value = '';
    }
});

// Clear button logic
document.getElementById('clearBtn').addEventListener('click', function() {
    if (confirm('Are you sure you want to clear the page?')) {
        dataCols = getInitialCols();
        dataRows = getInitialRows();
        renderTable();
        saveToStorage();
        clearPlot();
    }
});

// Test Data button logic
document.getElementById('testDataBtn').addEventListener('click', function() {
    if (!confirm('This will clear the table and insert test data. Continue?')) return;
    dataCols = getInitialCols();
    // Set up columns 1-6
    const labels = ["Semibalanus", "Chthamalus", "Greenish algae", "Brownish algae", "Winkles", "Dogwelks"];
    const types = ["% cover", "% cover", "% cover", "% cover", "count", "count"];
    for (let i = 0; i < 6; ++i) {
        dataCols[i].label = labels[i];
        dataCols[i].type = types[i];
    }
    dataRows = [];
    let cumulativeLength = 0;
    for (let i = 0; i < 20; ++i) {
        const height = +(i * 0.4).toFixed(2);
        const length = +cumulativeLength.toFixed(2);
        let row = { height: height, length: length, data: Array(NUM_DATA_COLS).fill('') };
        // Col 1: normal(mean=height*12.5, sd=10), truncated 0-100, 1dp
        row.data[0] = sampleNormalTrunc(height*12.5, 10, 0, 100, 1);
        // Col 2: normal(mean=8-height*12.5, sd=10), truncated 0-100, 1dp
        row.data[1] = sampleNormalTrunc(8-height*12.5, 10, 0, 100, 1);
        // Col 3: normal(mean=height*12.5, sd=10), truncated 0-100, 1dp
        row.data[2] = sampleNormalTrunc(height*12.5, 10, 0, 100, 1);
        // Col 4: normal(mean=8-height*12.5, sd=10), truncated 0-100, 1dp
        row.data[3] = sampleNormalTrunc(8-height*12.5, 10, 0, 100, 1);
        // Col 5: poisson(mean=10)
        row.data[4] = samplePoisson(10);
        // Col 6: poisson(mean=height)
        row.data[5] = samplePoisson(height);
        dataRows.push(row);
        // Add random increment for next row (uniform between -0.5 and 2.0)
        cumulativeLength += Math.random() * 1.8 + 0.2;
    }
    if (dataRows.length === 0) dataRows = [createEmptyRow()];
    renderTable();
    saveToStorage();
    // Auto-plot the test data
    document.getElementById('plotDataBtn').click();
});

// Helper: sample from normal distribution, truncated, with decimal places
function sampleNormalTrunc(mean, sd, min, max, decimals) {
    // Clamp mean to [min, max] to avoid impossible sampling
    mean = Math.max(min, Math.min(max, mean));
    let val;
    let attempts = 0, maxAttempts = 100;
    do {
        val = mean + sd * boxMullerRandom();
        attempts++;
        if (attempts > maxAttempts) {
            // If can't find a value, return closest bound
            return Number(Math.max(min, Math.min(max, val)).toFixed(decimals));
        }
    } while (val < min || val > max);
    return Number(val.toFixed(decimals));
}
// Helper: standard normal
function boxMullerRandom() {
    let u = 0, v = 0;
    while(u === 0) u = Math.random();
    while(v === 0) v = Math.random();
    return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
}
// Helper: sample from Poisson distribution
function samplePoisson(lambda) {
    let L = Math.exp(-lambda);
    let k = 0;
    let p = 1;
    do {
        k++;
        p *= Math.random();
    } while (p > L);
    return k - 1;
}

// Initialize
if (!loadFromStorage()) {
    dataCols = getInitialCols();
    dataRows = getInitialRows();
} else {
    // Auto-plot the loaded data
    setTimeout(() => document.getElementById('plotDataBtn').click(), 100);
}
renderTable();
</script>
</body>
</html>
